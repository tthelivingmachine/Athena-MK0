#ruledef registers
{
	a => 0x1`3
	b => 0x2`3
	c => 0x3`3
	d => 0x4`3
}

#ruledef
{
    mov {r: registers}, acc => 0x0 @ r
    mov acc, {r: registers} => 0x1 @ r
    add acc, {r: registers} => 0x2 @ r
    sub acc, {r: registers} => 0x3 @ r
    and acc, {r: registers} => 0x4 @ r
    or acc, {r: registers} => 0x5 @ r
    shr acc, {r: registers} => 0x6 @ r
    ret => 0x38
}

#ruledef
{
    mov acc, {imm8: i8} => 0x9 @ 0x0 @ imm8
    add acc, {imm8: i8} => 0xA @ 0x0 @ imm8
    pop {r: registers} => 0xB @ r
    push {r: registers} => 0xC @ r
    load {r: registers}, [{rs0: registers},{rs1: registers}] => 0xE @ r @ rs0 @ rs1
    store {r: registers}, [{rs0: registers},{rs1: registers}] => 0xF @ r @ rs0 @ rs1
}

#ruledef
{
    beq {imm8: i8} => 0xD @ 0x0 @ imm8     ; Z == 1
    bne {imm8: i8} => 0xD @ 0x1 @ imm8     ; Z == 0
    blt {imm8: i8} => 0xD @ 0x2 @ imm8     ; signed (N xor V) == 1
    bge {imm8: i8} => 0xD @ 0x3 @ imm8     ; signed (N xor V) == 0
    blo {imm8: i8} => 0xD @ 0x4 @ imm8     ; unsigned (C == 1)
    bhs {imm8: i8} => 0xD @ 0x5 @ imm8     ; unsigned (C == 0)
    bra {imm8: i8} => 0xD @ 0x6 @ imm8     ; always

    beq {imm16: i16} => 0x13 @ 0x0 @ imm16
    bne {imm16: i16} => 0x13 @ 0x1 @ imm16
    blt {imm16: i16} => 0x13 @ 0x2 @ imm16
    bge {imm16: i16} => 0x13 @ 0x3 @ imm16
    blo {imm16: i16} => 0x13 @ 0x4 @ imm16
    bhs {imm16: i16} => 0x13 @ 0x5 @ imm16
    bra {imm16: i16} => 0x13 @ 0x6 @ imm16
}

#ruledef
{
    load {r: registers}, {imm16: i16} => 0x10 @ r @ imm16
    store {r: registers}, {imm16: i16} => 0x11 @ r @ imm16
    call {imm16: i16} => 0x12 @ 0x0 @ imm16
}
